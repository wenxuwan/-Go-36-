# 第六章重点： #


go语言数据类型：**基础类型(数字，字符串，布尔类型),复合类型(数组，结构体),引用类型(指针，切片，字典，函数和通道),接口类型**

当重名变量的类型不同的时候，我们就需要注意存在的屏蔽现象了。所以使用的时候就需要注意类型判断了。


## 类型断言 ##

	value, ok := interface{}(变量名字).(类型的字面量)

	返回值解析：
		
		如果断言成功，value保存断言后的值。Ok代表的是否成功。如果失败value为Nil，ok为false。
		也可以不加Ok,直接用value=来接收，但如果断言失败就会发生panic异常导致代码崩溃。当然可以用recover来捕获panic异常并处理。
	
	类型断言的语法形式为x.(T)，x代表的是要被断言的值，这个值必须为借口类型。所以如果你的变量不是接口的时候需要转换成接口。

***

##类型转换注意地方##
	
	1.对于整数类型的值之间的转换，原则上只要源值在目标类型的表示范围内，就认为合理
	
	2.整数转string直接转世可行的，但必须保证整数值是一个有效的Unicode的代码点。不然就会出现乱码。
	
	3.string类型和切片之间的类型的互相转换

	string和byte之间的转换，因为对于Unicode编码来说除了asii的部门，byte是没法自己单独表示一个字符的，所以string的字符会被拆分成多个字节。
	
	The byte slice of "你好": e4 bd a0 e5 a5 bd

	如果拆分成rune类型的切片：

	The rune slice of "你好": [U+4F60 U+597D]
****

## 别名类型和潜在类型 ##

	别名类型声明方式
	
	var Mystring = string
	
	这里的Mystring和string是一样的，
	
	var Mystring2 string

	这里相当于定义了两个完全不同的类型，Mystring2和string是完全不同的两个类型。

	

##类型别名的作用##

在1.9中go语言引入了type alias, 类型别名主要对于代码重构具有重要的作用。

比如我们有类型变量T在lib1中，现在我们想把T移动到别的包里面（lib2），如果没有类型别名的话我们需要把引入包的所有文件都修改掉才能使用。但如果有类型别名，我们可以在lib1中直接声明：

	type T1=lib2.T1

这样我们并不影响整个系统的使用，后面可以慢慢的平滑过渡。

##类型别名和类型定义##

	type MyInt1 int
	type MyInt2=int
	
	第一行是定义了一个新的类型MyInt1，第二个只是给Int起了一个别名，实质上还是Int。
	
	var i int = 0
	var i1 MyInt1 = i //直接报错，因为go语言里面的不同类型转化需要显式转化
	var i2 MyInt2 = i

这个主要记住类型的别名就是给原类型起了个名字，实质上是一模一样的，但类型定义的话就完全是不同类型了。
