#通道的基本操作#

***

**通道本身是并发安全的，这也是go语言自带的唯一一个可以满足并发安全的的类型。**

##通道的初始化##

	通道的创建和字典一样，用的也是内置的make函数，make函数后面的参数代表了chan的长度，是否是带缓冲的chan。

	ch1 := make(chan int, 3)//创建一个int类型的chan，带3个缓冲
	
***

##通道的特性##


**1.对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。**

**2.发送操作和接收操作中对元素的操作都是不可分割的**

**3.发送操作和接收操作在完全完成之前都会被阻塞。**

对于第一个特性来说，指的是接收和发送的时候都只允许一个用户操作。就算是不同的goroutine，也只允许一个用户操作。

**一定要注意，往通道里面写数据的时候，写的是元素的副本，并不是元素的本身。读取的时候，也是先生成在通道里面的副本，然后准备给接收方，删除在通道的元素。**

第三个特性结合第二个特性，指的就是在通道读写的过程中必须完成，否则一直处于阻塞。
**写的时候两个操作：“复制元素值”，“放置副本到通道内部” 这两个步骤必须完成，否则会阻塞所在的goroutine。**
**读的时候三个步骤：“复制通道内的元素值“，”复制副本到接收方“，”删掉原值”**也是要阻塞的。

***
##发送和接收操作什么时候会被长时间阻塞##

###缓冲通道###

对于缓冲通道来说，如果通道满了，那么所有的写操作会依次进入等待队列。等到有读操作后按照队列顺序依次执行对应的goroutine。读操作的时候也是同样的原理，会一直等待有数据的写入。

###非缓冲通道###

对于非缓冲通道而言，不断是数据的读取还是写入，从一开始就是阻塞的了，直到配对的操作。**非缓冲通道，是直接从发送方复制到接收方，不会用非缓冲通道做中转。**相当于是同步传输，而缓冲通道是异步传输。



**对于nil类型的通道，不管他是什么类型。读写操作都会一直阻塞。所以一定要make初始化!!!!!!!** 

***
##发送操作和接收操作什么时候会触发panic？##

	1.对已经初始化，但未关闭的通道来说，收发操作一定不会引发panic
	2.通道已经关闭，写操作会触发panic
	3.读操作，可以返回两个值，一个是数据，一个是bool类型的代表通道是否关闭的值，如果通道关闭为false，否则为true。但记住通过第二个判断是否关闭是有延迟的（可能有数据还没读出，但对方close了chan，这种情况下，为true，同时返回的是通道里的数据）

##思考题##

###1.通道长度代表着什么，什么时候喝容量相同###

	长度代表的是当前通道包含的元素个数，容量的话就是make时候的值

###2.元素值在经过通道传递时会被复制，那么这个是浅表复制还是深层复制？

	浅表复制

	func main() {
		ch1 := make(chan int, 2)
		ch2 := make(chan []int, 2)
		l := []int{1,2,3}
		var l2 []int
		a := 0
		var b int
		go func() {
			ch1 <- a
			ch2 <- l
		}()
	
		select {
			case b = <-ch1:
				b = 100
		}
		select {
		case l2 = <-ch2:
			l2[0] = 100
		}
		fmt.Println(b,a)/100,0 切记这个地方不是发生了深层复制，而是go本身特性，对于基本数据类型，使用的是copy操作，所以内存不同。
		fmt.Println(l[0],l2[0]) //100,100 这个地方就可以看到两个切片用的是同一个底层的地址。
	
	}
	