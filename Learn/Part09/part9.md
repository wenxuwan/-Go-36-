#字典的操作和约束#

***
##字典的初始化##

	// 先声明map
	var m1 map[string]string
	// 再使用make函数创建一个非nil的map，nil map不能赋值
	m1 = make(map[string]string)
	// 最后给已声明的map赋值
	m1["a"] = "aa"
	m1["b"] = "bb"
	
	// 直接创建
	m2 := make(map[string]string)
	// 然后赋值
	m2["a"] = "aa"
	m2["b"] = "bb"
	
	// 初始化 + 赋值一体化
	m3 := map[string]string{
	    "a": "aa",
	    "b": "bb",
	}

**字典的底层就是个哈希表。**

**字典的key必须是能进行==和！=操作 ，这个是因为在查找的时候，会根据哈希值先找到哈希表对应的值，但这个值里面可能包含了多个key-value对（哈希碰撞），所以说需要再对key进行比较，才能确定是不是对应的value。**

**字典的key不允许 字典类型，切片类型，函数类型，因为不支持==和！=操作**

	Note:
		
		var badMap2 := map[interface{}] int{
						"1",	1
						[]int{2}:2    //引发panic
						3：3
			}
	
		这种声明用interface的确可以逃过编译器编译阶段，但在运行的时候就会触发panic异常了。

***

##优先考虑哪些类型作为key##

	因为key要求哈希值和进行比较，所以求哈希值越快的类型越好。
	求哈希值的速度和值类型的宽度相同（字节数）。
	所以优先选用数值类型和指针类型。

##对空的map进行操作##

	对nil的map除了添加新元素外，可以进行任何的操作！！！！！

	但切记不要添加元素，否则触发panic！！！！！！！！！！！！！！！！！

***
##思考题##

**在不同的goroutine 里面对map操作是安全的吗？或者说map是并发安全的吗？？**

	不是并发安全的，对于并发安全可以用go run -race 来做数据的竞争检测。